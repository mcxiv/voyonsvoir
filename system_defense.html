<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SYSTEM DEFENSE // V4.1 BALANCED</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        :root {
            --bg-color: #050505;
            --term-green: #0f0;
            --term-glow: #00ff00;
            --term-red: #ff3333;
            --term-blue: #00f3ff;
            --term-gold: #ffd700;
            --term-purple: #bd00ff; /* Couleur Cryptée */
            --ui-font: 'Share Tech Mono', monospace;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--term-green);
            font-family: var(--ui-font);
            height: 100vh;
            width: 100vw;
            user-select: none;
            transition: box-shadow 0.3s;
        }

        body.frozen { box-shadow: inset 0 0 50px var(--term-blue); }
        body.emp-flash { animation: flashWhite 0.5s; }

        @keyframes flashWhite {
            0% { background-color: white; }
            100% { background-color: var(--bg-color); }
        }

        /* Effet CRT */
        .crt-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
                        radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.6) 100%);
            background-size: 100% 4px, 100% 100%;
            z-index: 10;
        }

        /* Alert Overlay (Boss) */
        .alert-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: red; opacity: 0; pointer-events: none; z-index: 9;
            transition: opacity 0.5s; mix-blend-mode: overlay;
        }
        .boss-active .alert-overlay { animation: pulseAlert 1s infinite; }
        @keyframes pulseAlert { 0% { opacity: 0; } 50% { opacity: 0.3; } 100% { opacity: 0; } }

        /* HUD */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; z-index: 15;
            padding: 20px; box-sizing: border-box;
        }

        .hud-top {
            display: flex; justify-content: space-between; align-items: flex-start;
            font-size: 1.5rem; text-shadow: 0 0 10px var(--term-glow);
        }

        .stat-block {
            display: flex; flex-direction: column; background: rgba(0,0,0,0.6);
            padding: 10px; border-radius: 4px; border: 1px solid rgba(0,255,0,0.2);
        }
        
        .label { font-size: 0.8rem; opacity: 0.7; }
        .value { font-size: 1.8rem; font-weight: bold; }

        .combo-box {
            color: var(--term-gold); text-shadow: 0 0 10px var(--term-gold); text-align: center;
            opacity: 0; transition: opacity 0.2s;
        }
        .combo-active { opacity: 1; }

        /* EMP BAR */
        .emp-container {
            width: 200px; margin-top: 10px;
            display: flex; flex-direction: column; align-items: center;
        }
        .emp-bar-frame {
            width: 100%; height: 10px; border: 1px solid var(--term-blue); padding: 2px;
        }
        .emp-fill {
            width: 0%; height: 100%; background-color: var(--term-blue);
            box-shadow: 0 0 10px var(--term-blue); transition: width 0.2s;
        }
        .emp-ready .emp-fill { background-color: white; box-shadow: 0 0 20px var(--term-blue); }
        .emp-label { font-size: 0.9rem; color: var(--term-blue); margin-bottom: 5px; }

        #bonus-msg {
            position: absolute; top: 30%; left: 50%; transform: translateX(-50%);
            font-size: 3rem; font-weight: bold; opacity: 0; transition: opacity 0.5s;
            text-shadow: 0 0 20px currentColor; z-index: 18; text-align: center; width: 100%;
        }

        .integrity-bar-container {
            width: 300px; height: 20px; border: 2px solid var(--term-green); padding: 2px;
            margin-top: 5px; background: rgba(0,0,0,0.5);
        }
        .integrity-fill {
            height: 100%; background-color: var(--term-green); width: 100%;
            box-shadow: 0 0 10px var(--term-glow); transition: width 0.2s, background-color 0.2s;
        }

        /* Menus */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(5, 5, 5, 0.95); z-index: 20; pointer-events: auto;
            backdrop-filter: blur(5px); transition: opacity 0.5s;
        }

        h1 {
            font-size: 4rem; margin: 0; text-shadow: 0 0 20px var(--term-green);
            letter-spacing: 5px; text-align: center; margin-bottom: 20px;
        }

        .stats-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px; text-align: left;
            margin-bottom: 20px; border: 1px solid var(--term-green); padding: 20px;
            background: rgba(0,20,0,0.5);
        }
        
        .rank-title {
            font-size: 3rem; color: var(--term-gold); text-shadow: 0 0 20px var(--term-gold);
            margin: 20px 0; text-transform: uppercase;
        }

        .legend {
            display: flex; gap: 15px; margin-bottom: 30px; font-size: 0.9rem; flex-wrap: wrap; justify-content: center; max-width: 800px;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; margin: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
        .key-badge { background: #333; padding: 2px 6px; border-radius: 3px; font-family: monospace; border: 1px solid #666; color: white; }

        button {
            margin-top: 20px; background: transparent; color: var(--term-green);
            border: 2px solid var(--term-green); padding: 15px 40px; font-size: 1.5rem;
            font-family: var(--ui-font); cursor: pointer; text-transform: uppercase;
            transition: 0.2s; box-shadow: 0 0 10px var(--term-green); position: relative; z-index: 30;
        }
        button:hover { background: var(--term-green); color: black; box-shadow: 0 0 30px var(--term-green); }

        .hidden { display: none !important; }
        .critical { background-color: var(--term-red) !important; box-shadow: 0 0 10px var(--term-red) !important; }
        .shake { animation: shake 0.5s; }

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        /* Canvas Layers */
        #matrixCanvas { position: absolute; top: 0; left: 0; z-index: 0; }
        #gameCanvas { position: absolute; top: 0; left: 0; z-index: 1; }
    </style>
</head>
<body>

    <div class="crt-overlay"></div>
    <div class="alert-overlay"></div>

    <!-- HUD -->
    <div id="ui-layer">
        <div id="bonus-msg">SYSTEM FREEZE</div>

        <div class="hud-top">
            <!-- Left Stats -->
            <div class="stat-block">
                <span class="label">SCORE</span>
                <span class="value" id="score">0</span>
            </div>
            
            <!-- Center Combo & EMP -->
            <div style="display:flex; flex-direction:column; align-items:center;">
                <div class="combo-box" id="combo-display">
                    <span class="label">COMBO</span><br>
                    <span class="value" id="combo-val">x1</span>
                </div>
                
                <div class="emp-container">
                    <div class="emp-label">EMP CHARGE (SPACE)</div>
                    <div class="emp-bar-frame">
                        <div id="emp-bar" class="emp-fill"></div>
                    </div>
                </div>
            </div>

            <!-- Right Stats -->
            <div class="stat-block" style="text-align: right;">
                <span class="label">WAVE</span>
                <span class="value" id="level">1</span>
            </div>
        </div>

        <div style="align-self: flex-end; color: var(--term-red); text-shadow: 0 0 5px red;">
            SYSTEM INTEGRITY
            <div class="integrity-bar-container">
                <div id="integrity" class="integrity-fill"></div>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="screen">
        <h1>SYSTEM DEFENSE</h1>
        <p>
            V4.1 UPDATE<br>
            Protégez le noyau contre l'intrusion massive.
        </p>

        <div class="legend">
            <div class="legend-item"><span class="dot" style="background:var(--term-green)"></span> NORMAL</div>
            <div class="legend-item"><span class="dot" style="background:var(--term-blue)"></span> FREEZE</div>
            <div class="legend-item"><span class="dot" style="background:var(--term-purple)"></span> CRYPTÉ (<span class="key-badge">TAB</span>)</div>
            <div class="legend-item"><span class="dot" style="background:var(--term-red)"></span> BOSS</div>
            <div class="legend-item"><span class="dot" style="background:white"></span> EMP (<span class="key-badge">SPACE</span>)</div>
        </div>

        <button onclick="initAudioAndStart()">INITIATE SEQUENCE</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen hidden">
        <h1 style="color: var(--term-red);">SYSTEM FAILURE</h1>
        
        <div class="rank-title" id="final-rank">SCRIPT KIDDIE</div>

        <div class="stats-grid">
            <div>SCORE FINAL:</div><div id="final-score" style="text-align:right">0</div>
            <div>PRÉCISION:</div><div id="final-accuracy" style="text-align:right">0%</div>
            <div>ACTIONS/MIN:</div><div id="final-apm" style="text-align:right">0</div>
            <div>WAVE ATTEINTE:</div><div id="final-wave" style="text-align:right">0</div>
        </div>

        <button onclick="resetGame()">REBOOT SYSTEM</button>
    </div>

    <canvas id="matrixCanvas"></canvas>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const mCanvas = document.getElementById('matrixCanvas');
        const mCtx = mCanvas.getContext('2d');

        // --- AUDIO ENGINE ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let droneOsc, lfoOsc, droneGain;
        let bossMusicInterval; // Pour le beat du boss
        
        const Sounds = {
            type: () => playTone(800, 'square', 0.05, 0.05),
            lock: () => playTone(1200, 'sine', 0.1, 0.05),
            scan: () => { playTone(2000, 'sawtooth', 0.1, 0.1); playTone(1800, 'sawtooth', 0.1, 0.1, 0.1); },
            emp: () => { playNoise(1.0); playTone(100, 'sawtooth', 1.0, 0.5); },
            explosion: () => playNoise(0.2), 
            bossHit: () => { playTone(150, 'sawtooth', 0.1, 0.2); playNoise(0.1); },
            bossDie: () => { playTone(100, 'sawtooth', 1.0, 0.5); playNoise(1.0); },
            freeze: () => { playTone(400, 'sine', 0.1, 0.1); setTimeout(() => playTone(300, 'sine', 0.3, 0.1), 100); },
            heal: () => { playTone(600, 'triangle', 0.1, 0.1); setTimeout(() => playTone(900, 'triangle', 0.3, 0.1), 100); },
            error: () => playTone(150, 'sawtooth', 0.1, 0.1),
            damage: () => playTone(100, 'sawtooth', 0.4, 0.3),
            start: () => { playTone(400, 'sine', 0.1, 0.1); setTimeout(() => playTone(1000, 'square', 0.4, 0.1), 200); },
            
            // --- MUSIQUE D'AMBIANCE ---
            startDrone: () => {
                if(droneOsc) return;
                droneOsc = audioCtx.createOscillator();
                droneOsc.type = 'sawtooth';
                droneOsc.frequency.value = 55;
                lfoOsc = audioCtx.createOscillator();
                lfoOsc.type = 'sine';
                lfoOsc.frequency.value = 0.2;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 200;
                const lfoGain = audioCtx.createGain();
                lfoGain.gain.value = 100;
                droneGain = audioCtx.createGain();
                droneGain.gain.value = 0.03;
                lfoOsc.connect(lfoGain);
                lfoGain.connect(filter.frequency);
                droneOsc.connect(filter);
                filter.connect(droneGain);
                droneGain.connect(audioCtx.destination);
                droneOsc.start();
                lfoOsc.start();
            },
            stopDrone: () => {
                if (droneOsc) { droneOsc.stop(); lfoOsc.stop(); droneOsc = null; }
            },

            // --- MUSIQUE DE BOSS ---
            startBossMusic: () => {
                Sounds.stopDrone(); // Arrête l'ambiance calme
                if (bossMusicInterval) return;
                
                let beatTick = 0;
                bossMusicInterval = setInterval(() => {
                    // Kick Drum (tous les temps)
                    if (beatTick % 4 === 0) playTone(60, 'square', 0.1, 0.3);
                    
                    // Hi-hat (contre-temps)
                    if (beatTick % 2 === 0) playNoise(0.05);

                    // Bassline d'urgence
                    const note = (beatTick % 8 < 4) ? 100 : 110; 
                    playTone(note, 'sawtooth', 0.1, 0.15);

                    beatTick++;
                }, 125); // ~120 BPM (vite)
            },
            stopBossMusic: () => {
                if (bossMusicInterval) {
                    clearInterval(bossMusicInterval);
                    bossMusicInterval = null;
                }
                Sounds.startDrone(); // Relance l'ambiance calme
            }
        };

        function playTone(freq, type, duration, vol, delay=0) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            setTimeout(() => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            }, delay * 1000);
        }

        function playNoise(duration) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            noise.connect(gain);
            gain.connect(audioCtx.destination);
            noise.start();
        }

        // --- MATRIX BACKGROUND ---
        let drops = [];
        const fontSize = 16;
        let columns;
        const matrixChars = "アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン0123456789";

        function initMatrix() {
            columns = Math.floor(width / fontSize);
            drops = [];
            for (let i = 0; i < columns; i++) drops[i] = Math.random() * -100;
        }

        function drawMatrix() {
            mCtx.fillStyle = "rgba(5, 5, 5, 0.1)"; 
            mCtx.fillRect(0, 0, width, height);
            mCtx.fillStyle = "#0F0"; 
            mCtx.font = fontSize + "px monospace";
            for (let i = 0; i < drops.length; i++) {
                const text = matrixChars.charAt(Math.floor(Math.random() * matrixChars.length));
                mCtx.fillText(text, i * fontSize, drops[i] * fontSize);
                if (drops[i] * fontSize > height && Math.random() > 0.975) drops[i] = 0;
                drops[i]++;
            }
        }

        // --- DATA & CONFIG ---
        let width, height;
        const resize = () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            mCanvas.width = width; mCanvas.height = height;
            ctx.font = '24px "Share Tech Mono", monospace';
            initMatrix();
        };
        window.addEventListener('resize', resize);

        const wordList = [
            "ACCESS", "ALGORITHM", "BACKDOOR", "BANDWIDTH", "BINARY", "BIOS", "BITCOIN", "BLOCKCHAIN", "BOTNET", "BUFFER", 
            "BYPASS", "CACHE", "CIPHER", "CLOUD", "CLUSTER", "CODE", "COMMAND", "COMPILER", "COOKIE", "CORRUPT", 
            "CYBER", "DATA", "DEBUG", "DECRYPT", "DENIAL", "DNS", "DOMAIN", "DOWNLOAD", "DRIVER", "ENCRYPT", 
            "ETHERNET", "EXPLOIT", "FIREWALL", "FIRMWARE", "FTP", "GATEWAY", "GIGABYTE", "GLITCH", "HACKER", "HARDWARE", 
            "HASH", "HEX", "HTML", "HTTP", "HYPERLINK", "INJECT", "INPUT", "INTERFACE", "IP", "JAVA", 
            "KERNEL", "KEY", "LATENCY", "LINUX", "LOGIC", "LOGIN", "MALWARE", "MATRIX", "MEMORY", "MODEM", 
            "MONITOR", "NETWORK", "NODE", "NULL", "OFFLINE", "ONLINE", "OUTPUT", "PACKET", "PASSWORD", "PHISHING", 
            "PING", "PIXEL", "PORT", "PROCESS", "PROTOCOL", "PROXY", "PYTHON", "QUERY", "RAM", "REBOOT", 
            "ROOT", "ROUTER", "RUNTIME", "SCRIPT", "SERVER", "SHELL", "SIGNAL", "SOCKET", "SOFTWARE", "SOURCE", 
            "SPAM", "SQL", "SSH", "STACK", "STATUS", "SYNTAX", "SYSTEM", "TCP", "TERMINAL", "TOKEN", 
            "TRAFFIC", "TROJAN", "UNIX", "UPLOAD", "URL", "USER", "VECTOR", "VIRUS", "VPN", "WEB", "WIFI", "WORM", "XML", "ZERO"
        ];

        const bossSegmentsList = [
            ["FIREWALL", "DAEMON", "ROOT"], ["SECURITY", "PROTOCOL", "OVERRIDE"], ["MAINFRAME", "ENCRYPT", "BYPASS"],
            ["NEURAL", "NETWORK", "PURGE"], ["SYSTEM", "KERNEL", "PANIC"]
        ];

        // --- GAME STATE ---
        let activeWords = [];
        let particles = [];
        let score = 0;
        let combo = 0;
        let integrity = 100;
        let wave = 1;
        let empCharge = 0; // 0 to 100
        let gameRunning = false;
        let lastTime = 0;
        let spawnTimer = 0;
        let spawnInterval = 2500; // AJUSTEMENT: 2000 -> 2500 (Plus lent au début)
        let globalSpeedMultiplier = 0.8; // AJUSTEMENT: 1.0 -> 0.8 (Plus lent au début)
        let lockedWordIndex = -1;
        let freezeTimer = 0;
        let bossActive = false;
        let bossSpawnedInWave = false;
        let gameStartTime = 0;

        // Stats tracking
        let stats = { hits: 0, misses: 0, keystrokes: 0 };

        // DOM Elements
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const integrityEl = document.getElementById('integrity');
        const comboDisplay = document.getElementById('combo-display');
        const comboVal = document.getElementById('combo-val');
        const empBar = document.getElementById('emp-bar');
        const empContainer = document.querySelector('.emp-container');
        const bonusMsg = document.getElementById('bonus-msg');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const body = document.body;

        class Word {
            constructor() {
                this.text = wordList[Math.floor(Math.random() * wordList.length)];
                this.x = Math.random() * (width - 200) + 50;
                this.y = -50;
                this.speed = (Math.random() * 1 + 0.5) * globalSpeedMultiplier;
                this.typedIndex = 0;
                this.isBoss = false;
                this.isEncrypted = false;
                
                const roll = Math.random();
                if (roll > 0.96) {
                    this.type = 'FREEZE'; this.color = '#00f3ff'; this.glow = '#00f3ff';
                } else if (roll > 0.92) {
                    this.type = 'HEAL'; this.color = '#ffd700'; this.glow = '#ffd700';
                } else if (roll > 0.85) {
                    this.type = 'CRYPT'; this.color = '#bd00ff'; this.glow = '#bd00ff';
                    this.isEncrypted = true;
                } else {
                    this.type = 'NORMAL'; this.color = '#0f0'; this.glow = '#0f0';
                }
            }

            update(deltaTime) {
                if (freezeTimer <= 0) {
                    this.y += this.speed * (deltaTime / 16);
                }
            }

            draw(ctx, isLocked) {
                ctx.font = 'bold 24px "Share Tech Mono", monospace';
                
                // Glow effect
                if (isLocked) { ctx.shadowBlur = 15; ctx.shadowColor = this.glow; }
                else if (this.type !== 'NORMAL') { ctx.shadowBlur = 8; ctx.shadowColor = this.glow; }
                else { ctx.shadowBlur = 0; }

                // Determine display text
                let displayText = this.text;
                if (this.isEncrypted && !isLocked) {
                    // Random glitch characters if encrypted and not locked
                    if (Math.random() > 0.1) displayText = this.getGlitchText(this.text.length);
                }

                const typedPart = this.isEncrypted ? "" : displayText.substring(0, this.typedIndex);
                const remainPart = this.isEncrypted ? displayText : displayText.substring(this.typedIndex);

                ctx.fillStyle = isLocked ? '#fff' : '#444';
                ctx.fillText(typedPart, this.x, this.y);
                const typedWidth = ctx.measureText(typedPart).width;

                ctx.fillStyle = this.color;
                ctx.globalAlpha = isLocked ? 1 : 0.8; 
                ctx.fillText(remainPart, this.x + typedWidth, this.y);
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }

            getGlitchText(len) {
                const chars = "#@&%$*!?:";
                let s = "";
                for(let i=0; i<len; i++) s += chars[Math.floor(Math.random()*chars.length)];
                return s;
            }
        }

        class Boss extends Word {
            constructor() {
                super();
                this.isBoss = true;
                this.type = 'BOSS';
                this.segments = [...bossSegmentsList[Math.floor(Math.random() * bossSegmentsList.length)]];
                this.text = this.segments[0];
                this.x = (width / 2) - 100;
                this.y = -80;
                this.speed = 0.15 * globalSpeedMultiplier; // Scale boss speed slightly
                this.color = '#ff0000';
                this.glow = '#ff0000';
                this.isEncrypted = false;
            }

            advanceSegment() {
                this.segments.shift();
                this.typedIndex = 0;
                if (this.segments.length > 0) {
                    this.text = this.segments[0];
                    return true;
                }
                return false;
            }

            draw(ctx, isLocked) {
                ctx.font = 'bold 16px monospace';
                ctx.fillStyle = '#ff0000';
                ctx.fillText(`THREAT LEVEL: CRITICAL [${this.segments.length}]`, this.x, this.y - 25);

                ctx.font = 'bold 40px "Share Tech Mono", monospace';
                ctx.shadowBlur = 20; ctx.shadowColor = this.glow;

                const typedPart = this.text.substring(0, this.typedIndex);
                const remainPart = this.text.substring(this.typedIndex);

                ctx.fillStyle = '#fff';
                ctx.fillText(typedPart, this.x, this.y);
                const typedWidth = ctx.measureText(typedPart).width;
                
                ctx.fillStyle = this.color;
                ctx.fillText(remainPart, this.x + typedWidth, this.y);
                ctx.shadowBlur = 0;
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 12;
                this.vy = (Math.random() - 0.5) * 12;
                this.life = 1.0;
                this.color = color || `rgb(0, 255, 0)`;
                this.size = Math.random() * 3 + 1;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life -= 0.04; }
            draw(ctx) {
                ctx.globalAlpha = this.life; ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }

        function spawnExplosion(x, y, color, count=20) {
            for(let i=0; i<count; i++) particles.push(new Particle(x, y, color));
        }

        function initAudioAndStart() {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            Sounds.start(); Sounds.startDrone();
            startGame();
        }

        function startGame() {
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            resize(); resetVars();
            gameRunning = true;
            gameStartTime = Date.now();
            requestAnimationFrame(gameLoop);
        }

        function resetGame() {
            gameOverScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            body.classList.remove('frozen');
            body.classList.remove('boss-active');
            Sounds.stopBossMusic();
            Sounds.stopDrone();
        }

        function resetVars() {
            activeWords = []; particles = [];
            score = 0; combo = 0; integrity = 100;
            wave = 1; empCharge = 0;
            spawnInterval = 2500; // AJUSTEMENT: 2500 au lieu de 2000
            globalSpeedMultiplier = 0.8; // AJUSTEMENT: 0.8 au lieu de 1
            lockedWordIndex = -1; freezeTimer = 0;
            bossActive = false; bossSpawnedInWave = false;
            stats = { hits: 0, misses: 0, keystrokes: 0 };
            updateHUD();
        }

        function gameOver() {
            gameRunning = false;
            Sounds.stopBossMusic();
            Sounds.stopDrone();
            Sounds.damage();
            
            const gameDurationMinutes = (Date.now() - gameStartTime) / 60000;
            const accuracy = stats.keystrokes > 0 ? Math.floor((stats.hits / stats.keystrokes) * 100) : 0;
            const apm = Math.floor(stats.keystrokes / (gameDurationMinutes || 1));
            
            // Determine Rank
            let rank = "SCRIPT KIDDIE";
            if (score > 50) rank = "NOOB HACKER";
            if (score > 100) rank = "GREY HAT";
            if (score > 200) rank = "NETRUNNER";
            if (score > 350 && accuracy > 90) rank = "CYBER GOD";

            document.getElementById('final-score').innerText = score;
            document.getElementById('final-accuracy').innerText = accuracy + "%";
            document.getElementById('final-apm').innerText = apm;
            document.getElementById('final-wave').innerText = wave;
            document.getElementById('final-rank').innerText = rank;

            gameOverScreen.classList.remove('hidden');
            body.classList.remove('frozen');
            body.classList.remove('boss-active');
        }

        function updateHUD() {
            scoreEl.innerText = score;
            levelEl.innerText = wave;
            integrityEl.style.width = integrity + "%";
            
            // EMP Logic
            empBar.style.width = empCharge + "%";
            if (empCharge >= 100) empContainer.classList.add('emp-ready');
            else empContainer.classList.remove('emp-ready');

            // Combo Logic
            if (combo > 1) {
                comboDisplay.classList.add('combo-active');
                comboVal.innerText = "x" + combo;
                comboVal.style.color = combo > 5 ? '#ff00ff' : '#ffd700'; 
            } else {
                comboDisplay.classList.remove('combo-active');
            }

            if (integrity < 30) integrityEl.classList.add('critical');
            else integrityEl.classList.remove('critical');
        }

        function showBonusMessage(text, color) {
            bonusMsg.innerText = text; bonusMsg.style.color = color;
            bonusMsg.style.opacity = 1;
            setTimeout(() => { bonusMsg.style.opacity = 0; }, 1500);
        }

        function breakCombo() {
            if (combo > 5) Sounds.error(); 
            combo = 0; updateHUD();
        }

        function increaseDifficulty() {
            if (score > 0 && score % 10 === 0) {
                wave++; bossSpawnedInWave = false;
                // AJUSTEMENT: Progression plus douce (0.05 au lieu de 0.1)
                globalSpeedMultiplier += 0.05; 
                spawnInterval = Math.max(600, spawnInterval - 50); // -50ms au lieu de -100ms
            }
        }

        function activateEMP() {
            if (empCharge < 100) return;
            empCharge = 0;
            Sounds.emp();
            body.classList.add('emp-flash');
            setTimeout(() => body.classList.remove('emp-flash'), 500);

            // Destroy all non-boss enemies
            for (let i = activeWords.length - 1; i >= 0; i--) {
                const word = activeWords[i];
                if (!word.isBoss) {
                    spawnExplosion(word.x+50, word.y, '#fff', 10);
                    score += 1;
                    activeWords.splice(i, 1);
                } else {
                    // Damage boss
                    if (word.advanceSegment()) {
                        spawnExplosion(word.x+100, word.y, '#f00', 10);
                        score += 10;
                    } else {
                        // Boss killed by EMP
                        spawnExplosion(word.x+100, word.y, '#f00', 50);
                        bossActive = false; body.classList.remove('boss-active');
                        Sounds.stopBossMusic(); // STOP MUSIC
                        activeWords.splice(i, 1);
                        score += 50;
                    }
                }
            }
            lockedWordIndex = -1; // Reset lock
            updateHUD();
        }

        function scanClosestEncrypted() {
            // Find closest encrypted word
            let closest = -1;
            let maxY = -Infinity;

            for (let i = 0; i < activeWords.length; i++) {
                if (activeWords[i].isEncrypted) {
                    if (activeWords[i].y > maxY) {
                        maxY = activeWords[i].y;
                        closest = i;
                    }
                }
            }

            if (closest !== -1) {
                activeWords[closest].isEncrypted = false;
                spawnExplosion(activeWords[closest].x + 50, activeWords[closest].y, '#bd00ff', 5);
                Sounds.scan();
                showBonusMessage("DÉCRYPTAGE OK", "#bd00ff");
            } else {
                Sounds.error();
            }
        }

        function gameLoop(timestamp) {
            if (!gameRunning) return;
            const deltaTime = timestamp - lastTime || 16;
            lastTime = timestamp;

            ctx.clearRect(0, 0, width, height);
            drawMatrix();

            if (freezeTimer > 0) {
                freezeTimer -= deltaTime;
                if (freezeTimer <= 0) { freezeTimer = 0; body.classList.remove('frozen'); }
            } else {
                spawnTimer += deltaTime;
                if (wave % 5 === 0 && !bossSpawnedInWave && !bossActive) {
                    bossActive = true; bossSpawnedInWave = true;
                    activeWords.push(new Boss());
                    body.classList.add('boss-active');
                    showBonusMessage("WARNING: FIREWALL DETECTED", "#ff0000");
                    Sounds.error();
                    Sounds.startBossMusic(); // START MUSIC
                } else if (spawnTimer > (bossActive ? spawnInterval * 2 : spawnInterval)) {
                    if (!bossActive || Math.random() > 0.5) activeWords.push(new Word());
                    spawnTimer = 0;
                }
            }

            for (let i = activeWords.length - 1; i >= 0; i--) {
                let word = activeWords[i];
                word.update(deltaTime);
                
                // Collision
                if (word.isBoss && word.y > height - 50) { integrity = 0; updateHUD(); gameOver(); return; }
                if (word.y > height - 20) {
                    integrity -= 10; Sounds.damage(); breakCombo();
                    body.classList.add('shake'); setTimeout(() => body.classList.remove('shake'), 500);
                    if (i === lockedWordIndex) lockedWordIndex = -1;
                    else if (i < lockedWordIndex) lockedWordIndex--; 
                    activeWords.splice(i, 1);
                    if (integrity <= 0) { integrity = 0; updateHUD(); gameOver(); return; }
                }
                updateHUD();
                word.draw(ctx, i === lockedWordIndex);
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i]; p.update(); p.draw(ctx);
                if (p.life <= 0) particles.splice(i, 1);
            }
            requestAnimationFrame(gameLoop);
        }

        window.addEventListener('keydown', (e) => {
            if (!gameRunning) return;
            
            // Special Keys
            if (e.code === 'Space') { activateEMP(); return; }
            if (e.code === 'Tab') { e.preventDefault(); scanClosestEncrypted(); return; }

            if (e.key.length > 1) return; // Ignore modifiers

            stats.keystrokes++;
            const key = e.key.toUpperCase();
            
            if (lockedWordIndex !== -1) {
                const word = activeWords[lockedWordIndex];
                if (!word) { lockedWordIndex = -1; return; }
                
                // Can't type if encrypted
                if (word.isEncrypted) {
                    Sounds.error(); breakCombo(); return;
                }

                if (key === word.text[word.typedIndex]) {
                    word.typedIndex++;
                    stats.hits++;
                    Sounds.type();
                    
                    if (word.typedIndex === word.text.length) {
                        // Word Destroyed
                        if (word.isBoss) {
                            Sounds.bossHit();
                            spawnExplosion(word.x + 100, word.y, '#f00', 10);
                            body.classList.add('shake'); setTimeout(() => body.classList.remove('shake'), 200);
                            if (!word.advanceSegment()) {
                                Sounds.bossDie(); spawnExplosion(word.x + 100, word.y, '#f00', 50);
                                showBonusMessage("FIREWALL BREACHED", "#0f0");
                                score += 50; bossActive = false; body.classList.remove('boss-active');
                                Sounds.stopBossMusic(); // STOP MUSIC
                                activeWords.splice(lockedWordIndex, 1); lockedWordIndex = -1;
                            }
                        } else {
                            Sounds.explosion(); spawnExplosion(word.x + 50, word.y, word.color);
                            // Bonuses
                            if (word.type === 'FREEZE') { freezeTimer = 3000; body.classList.add('frozen'); Sounds.freeze(); showBonusMessage("SYSTEM FREEZE", "#00f3ff"); }
                            else if (word.type === 'HEAL') { integrity = Math.min(100, integrity + 15); Sounds.heal(); showBonusMessage("REPAIR +15%", "#ffd700"); }
                            
                            score += (1 + Math.floor(combo / 5));
                            combo++;
                            empCharge = Math.min(100, empCharge + 5); // Charge EMP

                            activeWords.splice(lockedWordIndex, 1);
                            lockedWordIndex = -1;
                            increaseDifficulty();
                        }
                        updateHUD();
                    }
                } else {
                    stats.misses++; Sounds.error(); breakCombo();
                }
            } else {
                // Find new target
                let bestIdx = -1; let maxY = -Infinity;
                for (let i = 0; i < activeWords.length; i++) {
                    // Cannot lock onto encrypted words
                    if (!activeWords[i].isEncrypted && activeWords[i].text.startsWith(key)) {
                        if (activeWords[i].y > maxY) { maxY = activeWords[i].y; bestIdx = i; }
                    }
                }

                if (bestIdx !== -1) {
                    lockedWordIndex = bestIdx;
                    activeWords[bestIdx].typedIndex = 1;
                    stats.hits++;
                    Sounds.lock();
                    if (activeWords[bestIdx].text.length === 1 && !activeWords[bestIdx].isBoss) {
                        // Instant kill single letter
                        Sounds.explosion(); spawnExplosion(activeWords[bestIdx].x, activeWords[bestIdx].y, activeWords[bestIdx].color);
                        activeWords.splice(bestIdx, 1); lockedWordIndex = -1;
                        score++; combo++; empCharge = Math.min(100, empCharge + 5);
                        increaseDifficulty(); updateHUD();
                    }
                } else {
                    stats.misses++; Sounds.error(); breakCombo();
                }
            }
        });
    </script>
</body>
</html>